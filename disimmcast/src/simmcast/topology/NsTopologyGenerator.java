/*
 * Simmcast - a network simulation framework
 * NsTopologyGenerator.java
 * Copyright (C) 2001-2003 Guilherme B. Bedin
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package simmcast.topology;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.StringTokenizer;
import java.util.Vector;

import simmcast.stream.FixedStream;

/**
 * This class builds a topology converting a
 * topology in the Ns format (as generated by sgb2ns, gt-itm).
 *
 * @author Guilherme Balestieri Bedin
 */
public class NsTopologyGenerator extends TopologyGenerator {

   // *************************************************
   // ATTRIBUTES
   // *************************************************

   private final String        fileName;

   private int                 actualLine = 0;

   private int                 nNodes;

   private String              ns = "ns";

   private String              node = "n";

   private Vector              paths = new Vector();
   
   // *************************************************
   // .SIM OPTIONS FOR ROUTERS
   // *************************************************

   private double              lossRateRouter = 0.00000;

   private int                 pathCapacityRouter = 0;

   private int                 rqLimitRouter = 0;

   private double              bandwidthRouter = 0.0000;

   private boolean             routerLinkSeted = false;

   // *************************************************
   // .SIM OPTIONS FOR HOSTS
   // *************************************************

   private double              lossRateHost = 0.00000;

   private int                 pathCapacityHost = 0;

   private int                 rqLimitHost = 0;

   private double              delayHost = 0.00000;

   private double              bandwidthHost = 0.0000;

   private boolean             hostLinkSeted = false;
   
   public NsTopologyGenerator(String file_) {
      fileName = file_;
   }

   protected void generatorFunction() throws TopologyGenerationException {
      if(!routerLinkSeted)
         throw new TopologyGenerationException(": Invalid routers links parameters");
   
      parse();

      for(int i = 0; i < paths.size(); i++) {
         TopologyPath tp = (TopologyPath)paths.elementAt(i);
         tp.bandwidth = bandwidthRouter;
         tp.lossRate = lossRateRouter;
         
         FixedStream fs = new FixedStream(tp.delay);
   
         routers[tp.from].addPath(routers[tp.to], pathCapacityRouter, tp.bandwidth, fs, tp.lossRate, rqLimitRouter);
         routers[tp.to].addPath(routers[tp.from], pathCapacityRouter, tp.bandwidth, fs, tp.lossRate, rqLimitRouter);
      }
      connectHostsOnAnyRouter();
   }

   private void connectHostsOnAnyRouter() throws TopologyGenerationException {
      if(!hostLinkSeted)
         throw new TopologyGenerationException(": Invalid hosts links parameters");
         
      FixedStream fs = new FixedStream(delayHost);
      for(int i=0; i < declaredHostCount; i++) {
         int index = (int)(Math.random() * declaredRouterCount);
         hosts[i].addPath(routers[index], pathCapacityHost, bandwidthHost, fs, lossRateHost, rqLimitHost);
         routers[index].addPath(hosts[i], pathCapacityHost, bandwidthHost, fs, lossRateHost, rqLimitHost);
      }
   }

   private void connectHostsOnLeafRouter() {}

   /**
    * Set the parameters of the links between hosts and routers.
    *
    * @param bandwidth_ bandwidth of the link between routers.
    * @param lossRate_ lossRate of the link between routers.
    * @param pathCapacity_ router send queue capacity.
    * @param rqLimit_ router receive queue capacity.
    */
   public void setRouterLink(double bandwidth_, double lossRate_, int pathCapacity_, int rqLimit_) throws TopologyGenerationException {
      if(((int)bandwidth_) > 0)
         bandwidthHost = bandwidth_;
      else
         throw new TopologyGenerationException(bandwidth_+": Invalid bandwidth for routers");
      
      if(lossRate_ > 0.000 || ((int)lossRate_) == 0)
         lossRateHost = lossRate_;
      else
         throw new TopologyGenerationException(lossRate_+": Invalid loss rate for routers");
         
      if(pathCapacity_ > 0)
         pathCapacityHost = pathCapacity_;
      else
         throw new TopologyGenerationException(pathCapacity_+": Invalid path capacity for routers");
      
      if(rqLimit_ > 0)
         rqLimitHost = rqLimit_;
      else
         throw new TopologyGenerationException(rqLimit_+": Invalid rq limit for routers");
         
      routerLinkSeted = true;
   }
   
   /**
    * Set the parameters of the links between hosts and routers.
    *
    * @param bandwidth_ bandwidth of the link between hosts and the routers.
    * @param lossRate_ lossRate of the link between hosts and the routers.
    * @param pathCapacity_ host send queue capacity.
    * @param rqLimit_ host receive queue capacity.
    * @param delay_ delay of the link between hosts and the routers.
    */
   public void setHostLink(double bandwidth_, double lossRate_, int pathCapacity_, int rqLimit_, double delay_) throws TopologyGenerationException {
      if(((int)bandwidth_) > 0)
         bandwidthHost = bandwidth_;
      else
         throw new TopologyGenerationException(bandwidth_+": Invalid bandwidth for hosts");
      
      if(lossRate_ > 0.000 || ((int)lossRate_) == 0)
         lossRateHost = lossRate_;
      else
         throw new TopologyGenerationException(lossRate_+": Invalid loss rate for hosts");
         
      if(delay_ > 0.000 || ((int)delay_) == 0)
         delayHost = delay_;
      else
         throw new TopologyGenerationException(delay_+": Invalid dealy for hosts");
         
      if(pathCapacity_ > 0)
         pathCapacityHost = pathCapacity_;
      else
         throw new TopologyGenerationException(pathCapacity_+": Invalid path capacity for hosts");
      
      if(rqLimit_ > 0)
         rqLimitHost = rqLimit_;
      else
         throw new TopologyGenerationException(rqLimit_+": Invalid rq limit for hosts");
         
      hostLinkSeted = true;
   }
   
   
   void parse() throws TopologyGenerationException {

      RandomAccessFile raf = null;
      try {
         raf = new RandomAccessFile(fileName, "r");
      } catch(FileNotFoundException fnfe) {
         throw new TopologyGenerationException(fileName+": Could not open Topology file");
      }

      try {
         String line;
         StringTokenizer st;
         while((line = raf.readLine()) != null) {
            st = new StringTokenizer(line);
            actualLine++;
            if(st.hasMoreTokens()) {
               String token = st.nextToken();

               if(token.startsWith("#")) {
                  if(comment(st))
                     continue;
                  else {
                     throw new TopologyGenerationException(fileName+": "+actualLine+": Invalid comment on topology file");
                  }
               }
               if(token.equals("return")) {
                  if(returnNumberOfNodes(st))
                     continue;
                  else {
                     throw new TopologyGenerationException(fileName+": "+actualLine+": Invalid return clause on topology file");
                  }
               }
               if(token.equals("proc")) {
                  token = st.nextToken();
                  if(token.equals("create-topology")) {
                     if(proc(st))
                        continue;
                     else {
                        throw new TopologyGenerationException(fileName+": "+actualLine+": Invalid procedure declaration on topology file");
                     }
                  }
                  else {
                     throw new TopologyGenerationException(fileName+": "+actualLine+": Unexpected procedure declaration on topology file");
                  }
               }
               if(token.equals("$"+ns)) {
                  token = st.nextToken();
                  if(token.equals("duplex-link")) {
                     if(path(st))
                        continue;
                     else {
                        throw new TopologyGenerationException(fileName+": "+actualLine+": Invalid link declaration on topology file");
                     }
                  }
               }
               if(token.equals("upvar"))
                  if(upvar(st))
                     continue;
                  else {
                     throw new TopologyGenerationException(fileName+": "+actualLine+": Invalid upvar declaration on Topology file");
                  }
            }
         }
      } catch(IOException ioe) {
         throw new TopologyGenerationException(ioe.toString());
      }

   }

   private boolean comment(StringTokenizer st_) {
      return true;
   }

   private boolean proc(StringTokenizer st_) {
      if(st_.countTokens() > 1) {
         String s  = st_.nextToken();
         if(!s.equals("{"))
            ns = s.substring(1,s.length());
         else {
            ns = st_.nextToken();
         }
         if(st_.hasMoreTokens())
            node = st_.nextToken();
         else
            return false;

         return true;
      }
      return false;
   }

   boolean upvar(StringTokenizer st_) {
      //upvar $node n
      if(st_.countTokens() > 1) {
         String s = st_.nextToken();
         if(s.equals("$"+ns)) {
            ns = st_.nextToken();
            return true;
         }
         else
            if(s.equals("$"+node)) {
               node = st_.nextToken();
               return true;
            }
      }
      return false;
   }

   private boolean returnNumberOfNodes(StringTokenizer st_) throws TopologyGenerationException {
      if(st_.hasMoreTokens()) {
         try {
            nNodes = Integer.parseInt(st_.nextToken().replaceAll(";",""));
            //System.out.println("nNodes: "+nNodes);
            return true;
         } catch(NumberFormatException  nfe) {
            throw new TopologyGenerationException("returnNumberOfNodes: "+nfe);
         }
      }
      return false;
   }

   private boolean path(StringTokenizer st_) throws TopologyGenerationException {
      //$ns duplex-link $n(1) $n(3) $linkBW 10.0ms DropTail
      int from, to;
      double delay;
      if(st_.countTokens() > 1) {
         try {
            String s = st_.nextToken();
            from = Integer.parseInt(s.substring(node.length()+2, s.length()-1));
            s = st_.nextToken();
            to = Integer.parseInt(s.substring(node.length()+2, s.length()-1));
            if(st_.hasMoreTokens()) {
               s = st_.nextToken();
               if(st_.hasMoreTokens()) {
                  s = st_.nextToken();
                  delay = Double.parseDouble(s.replaceFirst("ms",""));
                  paths.addElement(new TopologyPath(from, to, delay));
               }
            }
            else {
               paths.addElement(new TopologyPath(from, to));
            }
            return true;
         } catch(NumberFormatException  nfe) {
            throw new TopologyGenerationException("path: "+nfe);
         }
      }
      return false;
   }

}
