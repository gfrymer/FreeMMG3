package simmcast.network;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Type;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import simmcast.distribution.CloneOnWorker;
import simmcast.distribution.command.CommandProtocol;


/**
 * Packets are the unit of communication between any two or
 * more nodes. The packet class contains the minimal attributes
 * required by a packet in Simmcast. Both designs by inheritance
 * and by composition are supported: inheritance can be used to
 * easily define packet types for new protocols; nonetheless, a
 * packet is constructed as a container of an arbitrary object,
 * and this object may be defined to be the desired new packet
 * type.
 *
 * @author Hisham H. Muhammad
 */
public class Packet extends Queueable implements Cloneable, CloneOnWorker {

   // *****************************************************
   // ATTRIBUTES
   // *****************************************************

   /**
    * Numeric identifier of the packet's source (sender).
    * Corresponds to the network id of the Node that performed
    * the send operation, unless the Packet object is generated
    * by hand.
    */
   protected int from;

   /**
    * Numeric identifier of the packet's destination (receiver).
    * May be the network id of the Node to whom the unicast packet
    * is destined, or the network id of the multicast group to
    * which the packet was sent.
    */
   // TODO: this is not actually true. Upon arrival, the "to" field
   //       contains the node's id, not the group's. This should
   //       change.
   protected int to;

   /**
    * This packet's type (usually a handle to a static PacketType
    * in the simulation's Network).
    */
   protected PacketType type;

   /**
    * An automatically-generated unique identifier for the packet.
    */
   long seq;

   /**
    * Generic handle for holding data.
    */
   // TODO: must be "protected Cloneable data;"
   // to ensure packets are properly replicated and
   // prevent that two nodes share the same data object.
   protected Object data;

   /**
    * This static value controls the seq counting.
    */
   // TODO: non-const static variable. If an app using Simmcast
   // attempts to run multiple simulations simultaneously, it
   // will misbehave. Ideally this value would be stored on
   // the Network object, and the packet would ask a Node for
   // its seq which in turn would request a seq to the Network.
   // OTOH, this would be too slow and "static" serves our purpose
   // by now.
   static long seqControl = 0;

   /**
    * A numeric value representing the packet size
    * (used in bandwidth calculations, etc.)
    * This is a user-defined value for the simulation,
    * and does not correspond to the Packet object's size.
    */
   protected int size;

   // *****************************************************
   // CONSTRUCTORS
   // *****************************************************

   /**
    * Constructs a new packet with the specified characteristics.
    * No consistencies are made on the validity of the entered data.
    *
    * @param from_ Source node.
    * @param to_ Destination node.
    * @param type_ An object that identifies the packet type.
    * @param size_ The packet simulated size.
    *
    * @see #getSource
    * @see #getDestination
    * @see #getType
    * @see #getSize
    */
   public Packet(int from_, int to_, PacketType type_, int size_) {
      this(from_, to_, type_, size_, null);
   }

   /**
    * Constructs a new packet with the specified characteristics.
    * The packet holds a generic object.
    * No consistencies are made on the validity of the entered data.
    *
    * @param from_ Source node.
    * @param to_ Destination node.
    * @param type_ An object that identifies the packet type.
    * @param size_ The packet simulated size.
    * @param data_ An object, representing arbitrary data stored
    * inside the packet.
    *
    * @see #getSource
    * @see #getDestination
    * @see #getType
    * @see #getSize
    * @see #getData
    */
   public Packet(int from_, int to_, PacketType type_, int size_, Object data_) {
      from = from_;
      to = to_;
      type = type_;
      size = size_;
      seq = seqControl;
      seqControl++;
      data = data_;
   }

   // *****************************************************
   // GETTERS/SETTERS
   // *****************************************************

   /**
    * Contents of the "source" field.
    * Usually corresponds to the network id of the Node
    * that performed the send operation (unless the Packet object
    * is generated by hand).
    *
    * @return The numeric identifier (network id) of the
    * packet's source (sender).
    */
   public int getSource() {
      return from;
   }

   /**
    * Contents of the "destination" field,
    * which may be a multicast group or a single node's id.
    * it may be the network id of the Node to whom the unicast packet
    * is destined, or the network id of the multicast group to
    * which the packet was sent.
    *
    * @return The network id of the packet's receiver,
    */
   public int getDestination() {
      return to;
   }

   /**
    * Returns the packet's unique id.
    * It is an automatically-generated number that can be used
    * to ensure every packet in the simulation can be uniquely
    * identified. This can be useful for more high-level simulations,
    * as timestamping techniques can be abstracted.
    *
    * @return The packet's unique identifier.
    */
   public long getSeq() {
      return seq;
   }

   /**
    * This numeric value representing the packet size
    * is used in bandwidth calculations, etc.
    * This is a user-defined value for the simulation,
    * and does not correspond to the Packet object's size.
    *
    * @return The packet's simulated size.
    */
   public int getSize() {
      return size;
   }

   /**
    * Object used to identify a packet as being of a certain "type".
    * This "packet type" identifier can be used to
    * identify categories of packets through composition,
    * in case the programmer has many types of packets 
    * and wants to avoid extensive subclassing.
    *
    * @return The packet's type.
    */
   public PacketType getType() {
      return type;
   }

   /**
    * An object held by this packet.
    * A packet may hold an arbitrary object, representing
    * data stored inside a packet.
    *
    * @return An object stored in the packet, or null if
    * there is none.
    */
   public Object getData() {
      return data;
   }
   
   /**
    * Redefines the destination field of the packet.
    * This is used as a packet travels through hops.
    *
    * @param to_ The new destination.
    */
   public void setDestination(int to_) {
      to = to_;
   }

   // *****************************************************
   // PACKET REPLICATION
   // *****************************************************

   /**
    * Returns a cloned instance of this packet.
    * This is the lower-level routine used by replicate(),
    * that ensures that a newly created packet does not
    * hold references to the parent packet's context.
    *
    * @return The newly created packet object.
    */
   protected Packet newInstance() {
      try {
         Packet packet = (Packet)(this.clone());
         packet.back = null;
         packet.front = null;
         packet.mainBack = null;
         packet.mainFront = null;
         packet.seq = seqControl;
         seqControl++;
         return packet;
      } catch (CloneNotSupportedException e) {
         System.out.println(e);
         return new Packet(from, to, type, size, data);
      }
   }

   /**
    * Returns a new copy of this packet.
    * This is the proper routine to call to obtain
    * a replicated packet (instead of clone()), as
    * it guarantees consistency of the new packet's state,
    * making sure that it won't mix up with the original
    * packet (eg, having a different seq).
    *
    * @return The newly created packet object.
    */
   public Packet replicate() {
      Packet copy = newInstance();
      // TODO: Notice that threads that receive
      // copies of this packet will receive handles
      // of the same object!
      copy.data = data;
      return copy;
   }

   /**
    * Returns an array of packets, each addressed
    * to a specific members of the multicast group
    * this packet is originally addressed to.
    * This is an utility function, that performs mass replication
    * for members of the group.
    *
    * @param The Network object, from where group information
    * is obtained.
    *
    * @return An array containing one new Packet object for each
    * member of the group that was the original packet's destination
    * field.
    */
   // TODO: the "to" field should continue to report the
   //       multicast group. A possible solution is to have
   //       a "nominal" field and an "effective" one.
   public Packet[] expandPacket(Network network_) {
      // assert (network_.isMulticast(to));
      int[] members = network_.getGroups().getMembersById(to);
      Packet[] packets = new Packet[members.length];
      for (int i = 0; i < members.length; i++) {
         packets[i] = newInstance();
         packets[i].to = members[i];
      }
      return packets;
   }

   // *****************************************************
   // TRACE OUTPUT
   // *****************************************************

   /**
    * The string representation of the packet, as used in the
    * trace generation. Overriding this method, you can control
    * the way packets are displayed in the trace files. The
    * default behavior, however, will suffice most purposes,
    * as it relies on the contained object's toString ability
    * to display the "data" field.
    *
    * @return A string that shows the packet's "type", "id", "from",
    * "to" and "data" fields. The packet's output is parenthesized
    * to allow easy visualization when the data field contains
    * another packet.
    */
   public String toString() {
    //-----------------------------------------------------------------
   	// Obfuscate the '\n' character from data field:
	Object dataTrace = data;  
   	if (dataTrace != null) { 
       dataTrace = dataTrace.toString().replaceAll("\n", "\\\\n");
    }
    //-----------------------------------------------------------------
   	
   	return "(type "+type
            +" id "+seq
            +" from "+from
            +" to "+to
            +" (data "+dataTrace+"))";
   }

	public final static String FROM = "from";
	public final static String TO = "to";
	public final static String TYPE = "type";
	public final static String SIZE = "size";
	public final static String SEQUENCE = "seq";
	public final static String CLASS = "class";
	public final static String DATA = "data";

	@Override
	public String getConstructorParameters() {
		JsonObject gson = new JsonObject();
		gson.addProperty(FROM, from);
		gson.addProperty(TO, to);
		gson.addProperty(TYPE, type.name);
		gson.addProperty(SIZE, size);
		gson.addProperty(SEQUENCE, seq);
		gson.addProperty(CLASS, data.getClass().getName());
		if (data instanceof CloneOnWorker)
		{
			gson.addProperty(DATA, ((CloneOnWorker) data).getConstructorParameters());
		}
		else
		{
			gson.addProperty(DATA, data.toString());			
		}
		return gson.toString();
	}

	public static Packet fromJson(JsonObject jo)
	{
		int from = jo.get(FROM).getAsInt();
		int to = jo.get(TO).getAsInt();
		String type = jo.get(TYPE).getAsString();
		int size = jo.get(SIZE).getAsInt();
		long sequence = jo.get(SEQUENCE).getAsLong();
		String dataClassName = jo.get(CLASS).getAsString();
		try {
			Object n = null;
			Class r = Class.forName(dataClassName);
			try {
				java.lang.reflect.Method mt = r.getMethod("fromJson", JsonObject.class);
				n = mt.invoke(null, new JsonParser().parse(jo.get(DATA).getAsString()).getAsJsonObject());
			} catch (NoSuchMethodException ne)
			{
			}
			if (n==null)
			{
				Constructor[] c = r.getConstructors();
				for (int i=0;i<c.length;i++)
				{
					Type[] pt = c[i].getParameterTypes();
					if (pt.length==1)
					{
						if (pt[0].equals(String.class))
						{
							n = c[i].newInstance(jo.get(DATA).getAsString());
							break;
						}
						if (pt[0].equals(JsonObject.class))
						{
							n = c[i].newInstance(new JsonParser().parse(jo.get(DATA).getAsString()).getAsJsonObject());
							break;
						}
					}
				}
			}
			return new Packet(from, to, new PacketType(type), size, n);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			e.printStackTrace();
		}
		return null;
	}

}
